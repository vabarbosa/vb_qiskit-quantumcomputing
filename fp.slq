def toW[n:!â„•](qs:ğ”¹^n)mfree:ğ”¹^n{
  // for a single bit, prepare |1âŸ©
  if n==1{ qs[0]:=X(qs[0]); }
  else if n>1{
    // split qs into head (first element) and tail (rest)
    (head,)~tail:=qs;
    // prepare first bit
    Î¸:=2Â·asin(1/sqrt(n)); // sin(Î¸/2)=1/sqrt(n), cos(Î¸/2)=sqrt((n-1)/n)
    head:=rotY(Î¸,head); // |0âŸ© â†¦ cos(Î¸/2)|0âŸ© + sin(Î¸/2)|1âŸ© = cos(Î¸/2) |0âŸ© + 1/sqrt(n)|1âŸ©
    // prepare remaining bits
    if !head { tail := toW(tail); }
    // combine head and tail again
    qs:=(head,)~tail;
  }
  return qs;
}

def solve(qs:ğ”¹^3):!â„•{
  // transform Ïˆâ‚€ to Wâ‚ƒ
  if qs[1]{ phase(-2Â·Ï€/3); } // exp(2*i*Ï€/3)*exp(i*-2*Ï€/3)=1
  if qs[2]{ phase(-4Â·Ï€/3); } // exp(4*i*Ï€/3)*exp(i*-4*Ï€/3)=1
  // map Wâ‚ƒ to |000âŸ©
  qs:=reverse(toW[3])(qs);
  // check if obtained |000âŸ©
  return measure(qs as int[3])!=0;
}

// EXAMPLE CALL

def generate_input_state(state:!ğ”¹){
  // prepare Ïˆ_0 (state=false) or Ïˆ_1 (state=true)
  qs:=vector(3,0:ğ”¹);
  qs:=toW[3](qs);
  if state{
    if qs[1]{ phase(4Â·Ï€/3); }
    else if qs[2]{ phase(2Â·Ï€/3); }
  }else{
    if qs[1]{ phase(2Â·Ï€/3); }
    else if qs[2]{ phase(4Â·Ï€/3); }
  }
  return qs;
}

def main(){
  // expected outcome: (0,1)

  // prepare both states
  Ïˆ_0:=generate_input_state(false);
  Ïˆ_1:=generate_input_state(true);
  check0:=solve(Ïˆ_0);
  check1:=solve(Ïˆ_1);
  return (check0,check1);
}